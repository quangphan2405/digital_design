-- VHDL Entity alien_game_lib.c5_t3_reg_sda_moore.symbol
--
-- Created:
--          by - USER.UNKNOWN (QUANG-PHAN)
--          at - 22:09:13 06/ 1/2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.3 (Build 4)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY c5_t3_reg_sda_moore IS
   PORT( 
      clk      : IN     std_logic;
      color    : IN     std_logic_vector (23 DOWNTO 0);
      rst_n    : IN     std_logic;
      rx_ready : IN     std_logic;
      bit_out  : OUT    std_logic;
      channel  : OUT    std_logic_vector (7 DOWNTO 0);
      do_tx    : OUT    std_logic;
      lat      : OUT    std_logic;
      x        : OUT    std_logic_vector (7 DOWNTO 0);
      y        : OUT    std_logic_vector (7 DOWNTO 0)
   );

-- Declarations

END c5_t3_reg_sda_moore ;

--
-- VHDL Architecture alien_game_lib.c5_t3_reg_sda_moore.fsm
--
-- Created:
--          by - USER.UNKNOWN (QUANG-PHAN)
--          at - 22:09:13 06/ 1/2020
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.3 (Build 4)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
 
ARCHITECTURE fsm OF c5_t3_reg_sda_moore IS

   -- Architecture Declarations
   SIGNAL bit_idx : integer RANGE 24 DOWNTO 0;  
   SIGNAL channel_idx : integer RANGE 8 DOWNTO 0;  

   TYPE STATE_TYPE IS (
      init,
      px,
      inc_x,
      turn_off,
      toggle_lat,
      wait_for_lat,
      turn_on,
      wait_after_turn_on,
      inc_y,
      set_do_tx
   );
 
   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

   -- Declare Wait State internal signals
   SIGNAL csm_timer : std_logic_vector(12 DOWNTO 0);
   SIGNAL csm_next_timer : std_logic_vector(12 DOWNTO 0);
   SIGNAL csm_timeout : std_logic;
   SIGNAL csm_to_wait_for_lat : std_logic;
   SIGNAL csm_to_wait_after_turn_on : std_logic;

   -- Declare any pre-registered internal signals
   SIGNAL bit_out_cld : std_logic ;
   SIGNAL channel_cld : std_logic_vector (7 DOWNTO 0);
   SIGNAL do_tx_cld : std_logic ;
   SIGNAL lat_cld : std_logic ;
   SIGNAL x_cld : std_logic_vector (7 DOWNTO 0);
   SIGNAL y_cld : std_logic_vector (7 DOWNTO 0);

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clk,
      rst_n
   )
   -----------------------------------------------------------------
   BEGIN
      IF (rst_n = '0') THEN
         current_state <= init;
         csm_timer <= (OTHERS => '0');
         -- Default Reset Values
         bit_out_cld <= '0';
         channel_cld <= "00000000";
         do_tx_cld <= '0';
         lat_cld <= '0';
         x_cld <= "00000001";
         y_cld <= "00000001";
         bit_idx <= 0;
         channel_idx <= 0;
      ELSIF (clk'EVENT AND clk = '1') THEN
         current_state <= next_state;
         csm_timer <= csm_next_timer;

         -- Combined Actions
         CASE current_state IS
            WHEN init => 
               x_cld <= "00000001";
               y_cld <= "00000001";
               bit_idx <= 0;
               channel_idx <= 0;
               lat_cld <= '0';
               channel_cld <= "00000000";
               do_tx_cld <= '0';
            WHEN px => 
               bit_out_cld <= color(23 - bit_idx);
               bit_idx <= bit_idx + 1;
            WHEN inc_x => 
               x_cld<=x_cld(6 downto 0)& '0';
               bit_idx <= 0;
            WHEN turn_off => 
               channel_cld <= "00000000";
               bit_out_cld <= '0';
               do_tx_cld <= '0';
            WHEN toggle_lat => 
               lat_cld <= '1';
            WHEN turn_on => 
               channel_cld(channel_idx) <= '1';
               lat_cld <= '0';
            WHEN inc_y => 
               y_cld<=y_cld(6 downto 0)& '0';
               bit_idx <= 0;
               x_cld <= "00000001";
               channel_idx <= channel_idx + 1;
            WHEN set_do_tx => 
               do_tx_cld <= '1';
            WHEN OTHERS =>
               NULL;
         END CASE;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      bit_idx,
      channel_idx,
      csm_timeout,
      current_state,
      rx_ready,
      x_cld
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default assignments to Wait State entry flags
      csm_to_wait_for_lat <= '0';
      csm_to_wait_after_turn_on <= '0';
      CASE current_state IS
         WHEN init => 
            IF (rx_ready = '1') THEN 
               next_state <= px;
            ELSE
               next_state <= init;
            END IF;
         WHEN px => 
            IF (x_cld = "00000000") THEN 
               next_state <= turn_off;
            ELSIF (bit_idx = 23) THEN 
               next_state <= inc_x;
            ELSIF (bit_idx <23) THEN 
               next_state <= set_do_tx;
            ELSE
               next_state <= px;
            END IF;
         WHEN inc_x => 
            next_state <= set_do_tx;
         WHEN turn_off => 
            next_state <= wait_for_lat;
            csm_to_wait_for_lat <= '1';
         WHEN toggle_lat => 
            next_state <= turn_on;
         WHEN wait_for_lat => 
            IF (csm_timeout = '1') THEN 
               next_state <= toggle_lat;
            ELSE
               next_state <= wait_for_lat;
            END IF;
         WHEN turn_on => 
            next_state <= wait_after_turn_on;
            csm_to_wait_after_turn_on <= '1';
         WHEN wait_after_turn_on => 
            IF (csm_timeout = '1' AND (channel_idx < 7)) THEN 
               next_state <= inc_y;
            ELSIF (csm_timeout = '1' AND (channel_idx = 7)) THEN 
               next_state <= init;
            ELSE
               next_state <= wait_after_turn_on;
            END IF;
         WHEN inc_y => 
            next_state <= px;
         WHEN set_do_tx => 
            IF (rx_ready = '1') THEN 
               next_state <= px;
            ELSE
               next_state <= set_do_tx;
            END IF;
         WHEN OTHERS =>
            next_state <= init;
      END CASE;
   END PROCESS nextstate_proc;
 
   -----------------------------------------------------------------
   csm_wait_combo_proc: PROCESS (
      csm_timer,
      csm_to_wait_for_lat,
      csm_to_wait_after_turn_on
   )
   -----------------------------------------------------------------
   VARIABLE csm_temp_timeout : std_logic;
   BEGIN
      IF (unsigned(csm_timer) = 0) THEN
         csm_temp_timeout := '1';
      ELSE
         csm_temp_timeout := '0';
      END IF;

      IF (csm_to_wait_for_lat = '1') THEN
         csm_next_timer <= "1010101111011"; -- no cycles(5500)-1=5499
      ELSIF (csm_to_wait_after_turn_on = '1') THEN
         csm_next_timer <= "0111111101000"; -- no cycles(4073)-1=4072
      ELSE
         IF (csm_temp_timeout = '1') THEN
            csm_next_timer <= (OTHERS=>'0');
         ELSE
            csm_next_timer <= unsigned(csm_timer) - '1';
         END IF;
      END IF;
      csm_timeout <= csm_temp_timeout;
   END PROCESS csm_wait_combo_proc;

   -- Concurrent Statements
   -- Clocked output assignments
   bit_out <= bit_out_cld;
   channel <= channel_cld;
   do_tx <= do_tx_cld;
   lat <= lat_cld;
   x <= x_cld;
   y <= y_cld;
END fsm;
